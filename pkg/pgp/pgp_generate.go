/*
 *  Copyright (c) 2021-2025 Mikhail Knyazhev <markus621@gmail.com>. All rights reserved.
 *  Use of this source code is governed by a BSD-3-Clause license that can be found in the LICENSE file.
 */

package pgp

import (
	"bytes"
	"fmt"
	"io"
	"os"

	"golang.org/x/crypto/openpgp"
	"golang.org/x/crypto/openpgp/armor"
)

const (
	PublicFilename  = "public.pgp"
	PrivateFilename = "private.pgp"
)

var (
	keyHeaders = map[string]string{
		"Version":      "Golang OpenPGP",
		"Generated by": "github.com/osspkg/deb-builder",
	}
)

func (v *PGP) Generate(out string, name, comment, email string) error {
	buf := &bytes.Buffer{}

	key, err := openpgp.NewEntity(name, comment, email, nil)
	if err != nil {
		return fmt.Errorf("generate entity: %w", err)
	}

	if err = v.setup(key); err != nil {
		return fmt.Errorf("setup entity: %w", err)
	}

	if err = v.genPrivateKey(key, buf); err != nil {
		return fmt.Errorf("generate private key: %w", err)
	}

	if err = os.WriteFile(out+"/"+PrivateFilename, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("write private key: %w", err)
	}

	buf.Reset()

	if err = v.genPublicKey(key, buf); err != nil {
		return fmt.Errorf("generate public key: %w", err)
	}

	if err = os.WriteFile(out+"/"+PublicFilename, buf.Bytes(), 0600); err != nil {
		return fmt.Errorf("write public key: %w", err)
	}

	return nil
}

func (v *PGP) genPrivateKey(key *openpgp.Entity, w io.Writer) error {
	enc, err := armor.Encode(w, openpgp.PrivateKeyType, keyHeaders)
	if err != nil {
		return fmt.Errorf("create armor: %w", err)
	}

	defer enc.Close() //nolint: errcheck

	if err = key.SerializePrivate(enc, nil); err != nil {
		return fmt.Errorf("serialize private key: %w", err)
	}

	return nil
}

func (v *PGP) genPublicKey(key *openpgp.Entity, w io.Writer) error {
	enc, err := armor.Encode(w, openpgp.PublicKeyType, keyHeaders)
	if err != nil {
		return fmt.Errorf("create armor: %w", err)
	}

	defer enc.Close() //nolint: errcheck

	if err = key.Serialize(enc); err != nil {
		return fmt.Errorf("serialize public key: %w", err)
	}

	return nil
}

func (v *PGP) setup(key *openpgp.Entity) error {
	// Sign all the identities
	for _, id := range key.Identities {
		id.SelfSignature.PreferredCompression = []uint8{1, 2, 3, 0}
		id.SelfSignature.PreferredHash = []uint8{2, 8, 10, 1, 3, 9, 11}
		id.SelfSignature.PreferredSymmetric = []uint8{9, 8, 7, 3, 2}

		if err := id.SelfSignature.SignUserId(id.UserId.Id, key.PrimaryKey, key.PrivateKey, nil); err != nil {
			return err
		}
	}

	return nil
}
